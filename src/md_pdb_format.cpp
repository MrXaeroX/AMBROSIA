/***************************************************************************
* Copyright (C) 2013-2014 Alexander V. Popov.
* 
* This file is part of Amateur Modeling of Biopolymers: Restoration, 
* Optimization, Solvation & Initial Analysis (AMBROSIA) source code.
* 
* AMBROSIA source code is free software; you can redistribute it and/or 
* modify it under the terms of the GNU General Public License as 
* published by the Free Software Foundation; either version 2 of 
* the License, or (at your option) any later version.
* 
* AMBROSIA source code is distributed in the hope that it will be 
* useful, but WITHOUT ANY WARRANTY; without even the implied 
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
* See the GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software 
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
***************************************************************************/
#include "md_main.h"
#include "md_model.h"
#include "md_pdb_format.h"

const char *cPDBFormat :: m_sRecognizableHG[] = {
"101", "12A", "1AR", "1GL", "2AS", "2GL", "3AA", "3AT", "3DR", "3PO", "6HA", "6HC", "6HG", "6HT", 
"A26", "AA6", "ABD", "AC1", "ACO", "AIR", "AMU", "AMX", "AP5", "AMG", "APU", "B9A", "BCA", "BNA", 
"CAA", "CBS", "CGS", "CMC", "CND", "CO8", "COA", "COF", "COS", "DCA", "DGD", "FAB", "FAD", "FAG", 
"FAM", "FDA", "GPC", "IB2", "NAD", "NAH", "NAI", "NAL", "NAP", "NBD", "NDP", "PAD", "SAD", "SAE", 
"T5A", "tRE", "UP5", "ZID"
};

bool cPDBFormat :: IsRecognizableHG( const char *const resName )
{
	int hgSize = sizeof(m_sRecognizableHG) / sizeof(m_sRecognizableHG[0]);
	for (int i = 0; i < hgSize; i++) {
		if ( !strcmp( resName, m_sRecognizableHG[i] ) )
			return true;
	}
	return false;
}

bool cPDBFormat :: IsRecognizableGroup( const char *const resName )
{
	if ( Config().CheckResidueInfo( resName ) )
		return true;

	return IsRecognizableHG( resName );
}

// Automatic atomic symbol determination is described here:
// www.daylight.com/meetings/mug01/Sayle/m4xbondage.html
void cPDBFormat :: AutoAtomSymbol( DataElement &atom )
{
	memset( atom.mAtomSymbol, 0, sizeof(atom.mAtomSymbol) );

	// If symbol column provides an invalid atom name, use atom title to determine it.
	if ( (byte)(atom.mAtomTitle[0]) <= ' ' ) {
		// If the first character of the atom name is blank, and the third character is lower case,
		// the PDB file was generated by CONCORD and the atomic symbol is taken from the 2nd and 3rd characters.
		// As PDB files are normally only uppercase, CONCORD's incorrect column alignment is easy to recognize.
		if ( islower( atom.mAtomTitle[2] ) ) {
			atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
			atom.mAtomSymbol[1] = toupper( atom.mAtomTitle[2] );
			COM_Trim( atom.mAtomSymbol );
		}
		// If the first character is blank, and residue name denotes a hetero group that must have a prefix, 
		// and the third character is "H", "C", "N", "O", "P" or "S", the appropriate atomic number is used. 
		// If the third character is not one of these, the 2nd character is used as the atomic symbol. 
		// The current hetero groups that require a prefix are "GPC", "NAD" and "NDP" (which fixes 1rds).
		else if ( !strcmp( atom.mResidueTitle, "GPC" ) || !strcmp( atom.mResidueTitle, "NAD" ) || !strcmp( atom.mResidueTitle, "NDP" ) ) {
			if ( atom.mAtomTitle[2] == 'H' || 
				 atom.mAtomTitle[2] == 'C' || 
				 atom.mAtomTitle[2] == 'N' ||
				 atom.mAtomTitle[2] == 'O' ||
				 atom.mAtomTitle[2] == 'P' ||
				 atom.mAtomTitle[2] == 'S' ) {
				atom.mAtomSymbol[0] = atom.mAtomTitle[2];
			} else {
				atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
			}
		}
		// If the first character is blank, the second character is assumed to be the atomic symbol. 
		// If this character isn't recognized as an atomic symbol, and the third character contains "H", "C", "N", "O", "P" or "S", 
		// then the appropriate atomic number is used.
		else {
			atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
			if ( !Config().LookupAtomInfo( atom.mAtomSymbol ) ) {
				if ( atom.mAtomTitle[2] == 'H' || 
					 atom.mAtomTitle[2] == 'C' || 
					 atom.mAtomTitle[2] == 'N' ||
					 atom.mAtomTitle[2] == 'O' ||
					 atom.mAtomTitle[2] == 'P' ||
					 atom.mAtomTitle[2] == 'S' ) {
					atom.mAtomSymbol[0] = atom.mAtomTitle[2];
				} else {
					atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
					atom.mAtomSymbol[1] = toupper( atom.mAtomTitle[2] );
					COM_Trim( atom.mAtomSymbol );
				}
			}
		}
	} else if ( (byte)(atom.mAtomTitle[0]) >= '0' && (byte)(atom.mAtomTitle[0]) <= '9' ) {
		// If the first character is a digit, the second character is assumed to be the atomic symbol.
		atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
	} else if ( atom.mAtomTitle[0] == 'H' ) {
		// If the first character is "H", and the residue is a recognised amino acid, nucleic acid or special hetero group, 
		// then the atom is assumed to be hydrogen. For remaining groups, if the first two characters are a recognized 
		// atomic symbol, this is the element, or hydrogen if the first two characters are not a recognized atomic symbol. 
		// This fixes the Holmiums "Ho" and Mercuries "Hg" in numerous files (including 1f85).
		if ( IsRecognizableGroup( atom.mResidueTitle ) ) {
			atom.mAtomSymbol[0] = atom.mAtomTitle[0];
		} else {
			atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
			atom.mAtomSymbol[1] = toupper( atom.mAtomTitle[2] );
			COM_Trim( atom.mAtomSymbol );
			if ( !Config().LookupAtomInfo( atom.mAtomSymbol ) ) {
				atom.mAtomSymbol[0] = atom.mAtomTitle[0];
			}
		}
	} else if ( atom.mAtomTitle[0] == '\"' || atom.mAtomTitle[0] == '\'' || atom.mAtomTitle[0] == '*' ) {
		// If the first character is one of the symbols """, "'" or "*" then the second character is treated as the atomic symbol.
		atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
	} else {
		// If the residue name indicates a hetero group that uses an suffix, 
		// the the first character of the atom name is treated as the atomic symbol. 
		// The current hetero groups that require a suffix are "AGF", "COT" amd "FVF" (which fixes 1cjw).
		if ( !strcmp( atom.mResidueTitle, "AGF" ) || !strcmp( atom.mResidueTitle, "COT" ) || !strcmp( atom.mResidueTitle, "FVF" ) ) {
			atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[0] );
		}
		// If the residue name is one of the special hetero groups listed, 
		// the second character of the atom name is treated as the atomic symbol.
		if ( IsRecognizableHG( atom.mResidueTitle ) ) {
			atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[1] );
		}
		// The default, all remaining cases, treats the first two characters of the atom name as the atomic symbol. 
		// If the first two characters aren't a valid element, then the second character is treated as the atomic symbol.
		// Also fix Nd in recognizable groups to N
		atom.mAtomSymbol[0] = toupper( atom.mAtomTitle[0] );
		atom.mAtomSymbol[1] = toupper( atom.mAtomTitle[1] );
		COM_Trim( atom.mAtomSymbol );
		
		if ( !strcmp( atom.mAtomSymbol, "ND" ) && IsRecognizableGroup( atom.mResidueTitle ) ) {
			atom.mAtomSymbol[0] = 'N';
			atom.mAtomSymbol[1] = 0;
		} else if ( !Config().LookupAtomInfo( atom.mAtomSymbol ) ) {
			atom.mAtomSymbol[0] = atom.mAtomSymbol[1];
			atom.mAtomSymbol[1] = 0;
		}
	}
}

void cPDBFormat :: ReadFile( const char *const filename, DataHeader *const header, DataArray *const data )
{
	FILE *fp;
	char buffer[128];
	int loadModel = Config().Parameters().mLoadModel;
	int modelCounter = 0;

	m_atomCounter = 0;
	m_heavyAtomCounter = 0;
	m_residueCounter = 0;
	m_residueChainCounter = 0;
	m_chainCounter = 0;
	m_oldResidue = -99999;
	m_lastChainIdentifier = -1;
	m_lastResidueSequenceNumber = -1;
	memset( m_lastResidueTitle, 0, sizeof( m_lastResidueTitle ) );

	// Open the file
	if ( fopen_s( &fp, filename, "r" ) )
		Log().Fatal( "Couldn't read \"%s\"!\n", filename );

	Log().TPrintf( "Reading PDB file: \"%s\"\n", filename );

	// Parse the file line by line
	while ( !feof( fp ) ) {
		// Read line
		char *s = fgets( buffer, sizeof(buffer)-1, fp );
		if ( !s ) break;
		// Trim spaces
		COM_Trim( buffer );
		// Check command type
		if ( !_strnicmp( buffer, "ATOM  ", 6 ) ||
			 !_strnicmp( buffer, "HETATM", 6 ) ) {
			// Parse atom definition
			if ( modelCounter == loadModel )
				ReadAtom( buffer, sizeof(buffer), data );
		} else if ( !_strnicmp( buffer, "TER   ", 6 ) || 
					!_stricmp( buffer, "TER" ) ) {
			// Parse chain terminator
			if ( modelCounter == loadModel ) {
				m_lastChainIdentifier = -1;
				m_lastResidueSequenceNumber = -1;
				memset( m_lastResidueTitle, 0, sizeof( m_lastResidueTitle ) );
			}
		} else if ( !_strnicmp( buffer, "MODEL ", 6 ) || 
					!_stricmp( buffer, "MODEL" ) ) {
			// Parse model start
			if ( modelCounter != loadModel )
				Log().DPrintf( "Ignoring model %i\n", modelCounter );
			else
				Log().DPrintf( "Loading model %i\n", modelCounter );
		} else if ( !_strnicmp( buffer, "ENDMDL", 6 ) ) {
			// Parse model end
			if ( modelCounter == loadModel ) {
				m_lastChainIdentifier = -1;
				m_lastResidueSequenceNumber = -1;
				memset( m_lastResidueTitle, 0, sizeof( m_lastResidueTitle ) );
			}
			++modelCounter;
		} else if ( !_strnicmp( buffer, "END   ", 6 ) || 
					!_stricmp( buffer, "END" ) ) {
			// Parse END keyword
			break;
		} else if ( !_strnicmp( buffer, "REMARK", 6 ) ) {
			// Ignore remarks
		} else if ( *buffer ) {
			Log().DPrintf( "Ignoring line: %s\n", buffer );
		}
	}

	// Close the file
	fclose( fp );

	// Setup header
	header->mNumAtoms = m_atomCounter;
	header->mNumHeavyAtoms = m_heavyAtomCounter;
	header->mNumResidues = m_residueCounter;
	header->mNumChains = m_chainCounter;
}

void cPDBFormat :: WriteFile( const char *const filename, const DataHeader *const header, const DataArray *const data )
{
	FILE *fp;
	int lastChain = 1;
	int serialNumber = 0;

	// Open the file
	if ( fopen_s( &fp, filename, "w" ) )
		Log().Fatal( "Couldn't write \"%s\"!\n", filename );

	Log().TPrintf( "Writing PDB file: \"%s\"\n", filename );

	// Write comment, if any
	const char *pComment = header->mComment;
	if ( *pComment ) {
		int lastChar = '\n';
		while ( *pComment ) {
			if ( lastChar == '\n' )
				fputs( "REMARK ", fp );
			fputc( *pComment, fp );
			lastChar = *pComment++;
		}
	}

	// Write all atoms
	for ( DataArray::const_iterator it = data->begin(); it != data->end(); ++it, ++serialNumber ) {
		if ( it->mChainNumber != lastChain ) {
			lastChain = it->mChainNumber;
			fprintf( fp, "%-6s%5i\n", "TER", serialNumber );
		}
		WriteAtom( *it, serialNumber + 1, fp );
	}

	// Finalize
	fprintf( fp, "%-6s%5i\n", "TER", serialNumber );
	fprintf( fp, "%-6s\n", "END" );

	// Close the file
	fclose( fp );
}

void cPDBFormat :: ReadAtom( const char *const buffer, size_t bufferSize, DataArray *const data )
{
	DataElement atom;
	char tempBuffer[16];
	int chainIdentifier;

	UNREFERENCED_PARAMETER( bufferSize );

#if !defined(BIOPASED_COMPAT_PDB)
	// All atom records containing a character other than " ", "A" or "1" in the alternate location column (column 17) were ignored.
	// The convention on alternate locations is that the column be blank if the atom is unambiguously located, or contain the 
	// sequence "A", "B", "C" etc.. for each potential conformation for ambiguous atoms. Some PDB files use digits instead of letters.
	if ( (byte)(buffer[16]) > 32 && buffer[16] != 'A' && buffer[16] != '1' )
		return;
#endif

	// Clear data
	memset( &atom, 0, sizeof(atom) );

	// Get atom title
#if defined(BIOPASED_COMPAT_PDB)
	COM_Substr( buffer, 12, 5, atom.mAtomTitle, sizeof( atom.mAtomTitle ) );
#else
	COM_Substr( buffer, 12, 4, atom.mAtomTitle, sizeof( atom.mAtomTitle ) );
#endif

	// All atom records containing " Q" as the first two characters of the atom name were ignored. 
	// The element " Q" is commonly used in NMR processing to represent pseudo atoms used in refinement.
	if ( !strncmp( atom.mAtomTitle, " Q", 2 ) )
		return;

	//Atom name "UNK" represents an invalid atom serial number 0, ignore it
	if ( !strcmp( atom.mAtomTitle, "UNK" ) )
		return;

	// Get residue title
	COM_Substr( buffer, 17, 3, atom.mResidueTitle, sizeof( atom.mResidueTitle ) );
	COM_Trim( atom.mResidueTitle );

	// The residue name "DUM" is officially used to denote dummy atoms, such as in pdbcodes 1b3o and 1som, 
	// to represent unexplained electron density. All atom records with residue name "DUM" are ignored.
	if ( !strcmp( atom.mResidueTitle, "DUM" ) )
		return;	

	// Residue HIS doesn't exist in the topology
	// We must select between HIE, HID and HIP at our own
	// For now, always select HIE
	if ( !strcmp( atom.mResidueTitle, "HIS" ) )
		strcpy_s( atom.mResidueTitle, "HIE" );

	// Get atom symbol
	COM_Substr( buffer, 76, 2, atom.mAtomSymbol, sizeof( atom.mAtomSymbol ) );
	COM_Trim( atom.mAtomSymbol );
	if ( !atom.mAtomSymbol[0] || isdigit(atom.mAtomSymbol[0]) || atom.mAtomSymbol[0] == '.' )
		AutoAtomSymbol( atom );

	// Check if we ignore hydrogens
	if ( !strcmp( atom.mAtomSymbol, "H" ) && !Config().Parameters().mReadHydrogens )
		return;

	// Trim atom title (after we've determined atomic symbol, untrimmed name is not needed anymore)
	COM_Trim( atom.mAtomTitle );

	// Increment counter
	++m_atomCounter;

	if ( strcmp( atom.mAtomSymbol, "H" ) ) {
		atom.mFlags |= AF_HEAVY;
		++m_heavyAtomCounter;
	}

	// Get chain index
	chainIdentifier = (byte)(buffer[21]);
	if ( chainIdentifier != m_lastChainIdentifier ) {
		// New chain started
		m_residueChainCounter = 0;
		m_lastChainIdentifier = chainIdentifier;
		++m_chainCounter;
	}
	atom.mChainNumber = m_chainCounter;

	// Get residue sequence number
	COM_Substr( buffer, 22, 4, tempBuffer, sizeof( tempBuffer ) );
	atom.mResidueSequenceNumber = atoi( tempBuffer );
	if ( m_oldResidue != atom.mResidueSequenceNumber ) {
		m_oldResidue = atom.mResidueSequenceNumber;
		++m_residueChainCounter;
	}

	// Get residue index
	if ( m_lastResidueSequenceNumber != atom.mResidueSequenceNumber ||
		 strcmp( m_lastResidueTitle, atom.mResidueTitle ) ) {
		m_lastResidueSequenceNumber = atom.mResidueSequenceNumber;
		strcpy_s( m_lastResidueTitle, atom.mResidueTitle );
		++m_residueCounter;
	}
	atom.mResidueNumber = m_residueCounter;

	// Rebase if needed
	if ( Config().Parameters().mAutoRSN )
		atom.mResidueSequenceNumber = m_residueChainCounter;

	// Read coordinates
	for ( int i = 0; i < 3; ++i ) {
		COM_Substr( buffer, 30 + 8*i, 8, tempBuffer, sizeof( tempBuffer ) );
		atom.mOriginalPosition[i] = COM_Atof( tempBuffer );
	}

	Log().DPrintf( "ATOM  %5i %-4s %-3s %c%4i    %8.3f%8.3f%8.3f%22s%2s \n",
		m_atomCounter, atom.mAtomTitle, atom.mResidueTitle, 'A' + atom.mChainNumber - 1, atom.mResidueSequenceNumber, atom.mOriginalPosition[0], atom.mOriginalPosition[1], atom.mOriginalPosition[2], "", atom.mAtomSymbol );

	data->push_back( atom );
}

void cPDBFormat :: WriteAtom( const DataElement &atom, int serialNumber, FILE *fp )
{
	// Check if we have too many chains (e.g. isolated water molecules)
	char chainIdentifier = 'A' + atom.mChainNumber - 1;
	if ( chainIdentifier < 'A' || chainIdentifier > 'Z' )
		chainIdentifier = ' ';

	// If we have physAtoms allocated, write their position
	// Otherwise, write original positions
	const vec_t *pPosition = &atom.mOriginalPosition[0];
	if ( atom.mCurrentPosition )
		pPosition = atom.mCurrentPosition;

	// If we have charges allocated, write its value
	// Otherwise, write zero
	vec_t fCharge = 0;
	if ( atom.mpResidueAtom )
		fCharge = atom.mpResidueAtom->mCharge;

	// Hack for trimmed atomic name
	// First two columns usually denote atomic symbol
	// If symbol is 1-digit, add one extra space
	// Certainly, if name is too large, don't pad with spaces at all
	// Also write partial charges
#if defined(BIOPASED_COMPAT_PDB)
	fprintf( fp, "ATOM  %5i  %-4s%-3s %c%4i    %8.3f%8.3f%8.3f %6s%8.5f%7s%2s \n",
		serialNumber, atom.mAtomTitle, atom.mResidueTitle, chainIdentifier, atom.mResidueSequenceNumber, pPosition[0], pPosition[1], pPosition[2], "", fCharge, "", atom.mAtomSymbol );
#else
	if ( atom.mAtomSymbol[1] != 0 || strlen( atom.mAtomTitle ) >= 4 ) {
		fprintf( fp, "ATOM  %5i %-4s %-3s %c%4i    %8.3f%8.3f%8.3f %6s%8.5f%7s%2s \n",
			serialNumber, atom.mAtomTitle, atom.mResidueTitle, chainIdentifier, atom.mResidueSequenceNumber, pPosition[0], pPosition[1], pPosition[2], "", fCharge, "", atom.mAtomSymbol );
	} else {
		fprintf( fp, "ATOM  %5i  %-3s %-3s %c%4i    %8.3f%8.3f%8.3f %6s%8.5f%7s%2s \n",
			serialNumber, atom.mAtomTitle, atom.mResidueTitle, chainIdentifier, atom.mResidueSequenceNumber, pPosition[0], pPosition[1], pPosition[2], "", fCharge, "", atom.mAtomSymbol );
	}
#endif
}
